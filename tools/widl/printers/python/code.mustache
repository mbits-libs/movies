// Copyright (c) 2023 midnightBITS
// This code is licensed under MIT license (see LICENSE for details)

// THIS FILE IS AUTOGENERATED. DO NOT MODIFY

#include <movies/movie_info.hpp>
#include <py3/converter.hpp>
#include <boost/python/self.hpp>
#include <boost/python/operators.hpp>

namespace movies::v{{version}} {
	json::node simpler(json::node simpler, int level = 2);
{{#interfaces}}
{{^synthetic}}
	std::string internal__{{name}}__to_string({{name}} const&);
{{/synthetic}}
{{#operations}}
{{#external}}
	{{alias}} {{#needs_proxy}}proxy__{{/needs_proxy}}{{#staticmethod}}static__{{/staticmethod}}{{interfaces.name}}__{{name}}({{\}}
{{#arguments}}{{\}}
{{#this}}{{interfaces.name}}{{^ext_attrs.mutable}} const{{/ext_attrs.mutable}}&{{/this}}{{\}}
{{^this}}{{alias}}{{/this}} {{name}}{{^last}}, {{/last}}{{/arguments}}{{\}}
	);
{{/external}}
{{/operations}}
{{/interfaces}}
{{#interfaces}}
{{^synthetic}}

	std::ostream& operator<<(std::ostream& output, {{name}} const& value) {
		auto const string = internal__{{name}}__to_string(value);
		return output << string;
	}
{{/synthetic}}
{{/interfaces}}

	void setup_api() {
		using namespace boost::python;
		using self_ns::self;
		using self_ns::str;
{{#enums}}

		enum_<{{name}}>("{{name}}")
#define X_VALUE(NAME) .value(#NAME, {{name}}::NAME)
		    {{NAME}}_X(X_VALUE)
#undef X_VALUE
		    ;
{{/enums}}
{{#interfaces}}
{{^synthetic}}

		class_<{{name}}>("{{name}}")
{{#attributes}}
		    .def_readwrite("{{name}}", &{{interfaces.name}}::{{name}})
{{/attributes}}
{{#operations}}
		    .def("{{name}}", {{\}}
{{#external}}{{#needs_proxy}}proxy__{{/needs_proxy}}{{#staticmethod}}static__{{/staticmethod}}{{interfaces.name}}__{{name}}{{/external}}{{\}}
{{^external}}&{{interfaces.name}}::{{name}}{{/external}}{{\}}
		    )
{{#staticmethod}}
		    .staticmethod("{{name}}")
{{/staticmethod}}
{{/operations}}
			.def(str(self))
		    ;
{{#is_translatable}}

		translatable_<{{name}}>("translatable_{{name}}").def_tr();
{{/is_translatable}}
{{#is_vector}}

		vector_<{{name}}>("vector_{{name}}").def_vector();
{{/is_vector}}
{{/synthetic}}
{{/interfaces}}
	}
{{#interfaces}}
{{#operations}}
{{#external}}
{{#needs_proxy}}

	{{alias}} proxy__{{#staticmethod}}static__{{/staticmethod}}{{interfaces.name}}__{{name}}({{\}}
{{#arguments}}{{\}}
{{#this}}{{interfaces.name}}{{^ext_attrs.mutable}} const{{/ext_attrs.mutable}}&{{/this}}{{\}}
{{^this}}{{alias}}{{/this}} {{name}}{{^last}}, {{/last}}{{/arguments}}{{\}}
	) {
		return {{#staticmethod}}{{interfaces.name}}::{{/staticmethod}}{{\}}
		{{^staticmethod}}{{#arguments}}{{#this}}{{name}}.{{/this}}{{/arguments}}{{/staticmethod}}{{\}}
		{{name}}({{#arguments}}{{^this}}{{name}}{{^last}}, {{/last}}{{/this}}{{/arguments}});
	}
{{/needs_proxy}}
{{/external}}
{{/operations}}
{{/interfaces}}
{{#interfaces}}
{{^synthetic}}

	std::string internal__{{name}}__to_string({{name}} const& self) {
		auto node = simpler(self.to_json());
		std::u8string u8{};
		json::write_json(u8, node, json::concise);
		return as_ascii_string_v(u8);
	}
{{/synthetic}}
{{/interfaces}}
}  // namespace movies::v{{version}}
